import torch
# from torch_geometric.utils import erdos_renyi_graph
from networkx import erdos_renyi_graph
from powerful_gnns.models.graphcnn import GraphCNN
from powerful_gnns.util import *
from tqdm import tqdm
import networkx as nx
import json
from collections import defaultdict
from multiprocessing import Pool, Process
from utils import collision_probability, calc_collision_stats
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import os
import argparse
import sys
import time
from functools import partial

INPUT_DIM = 128

from time import sleep

def wl_experiment(num_nodes=1024,
                  edge_prob=0.5,
                  network_size=2,
                  seed=42,
                  num_permutations=200,
                  results_base_path='results'):

    print("started")

    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model_parms = {
        'num_layers': 5,
        'num_mlp_layers': network_size,
        'input_dim': INPUT_DIM,
        'hidden_dim': network_size * 32,
        'output_dim': 1,
        'final_dropout': 0.5,
        'learn_eps': True,
        'eps_freeze': True,
        'graph_pooling_type': 'average',
        'neighbor_pooling_type': 'average',
        'device': device,
        'eps_initialization': 'random'  # 1e-4

    }

    # initial seed
    torch.manual_seed(seed)

    model = GraphCNN(**model_parms).to(device)
    model.eval()

    print()

    node_features = torch.rand((num_nodes, INPUT_DIM), device=device)

    model_outputs = []

    def get_graph(i): return erdos_renyi_graph(num_nodes,
                                               edge_prob,
                                               seed=(seed + i)
                                               )

    for i in tqdm(range(num_permutations)):
        permutation = get_graph(i)

        graph = S2VGraph(permutation, None, None, node_features)

        edges = [list(pair) for pair in permutation.edges()]
        edges.extend([[i, j] for j, i in edges])
        graph.edge_mat = torch.LongTensor(edges).transpose(0, 1).to(device)

        graph.neighbors = [[] for i in range(len(permutation))]
        for i, j in permutation.edges():
            graph.neighbors[i].append(j)
            graph.neighbors[j].append(i)
        degree_list = []
        for i in range(len(permutation)):
            graph.neighbors[i] = graph.neighbors[i]
            degree_list.append(len(graph.neighbors[i]))
        graph.max_neighbor = max(degree_list)

        with torch.inference_mode():
            model_outputs.append(model([graph]))

    model_outputs = torch.cat(model_outputs, dim=0)

    output_counts = defaultdict(lambda: 0)
    output_indices = defaultdict(list)
    all_values = []
    for i, output in enumerate(model_outputs):

        key = None
        found = False

        for k in output_counts.keys():
            if ((output == k).all()
                    # and all([not nx.is_isomorphic(get_graph(i),
                    #  get_graph(j)) for j in output_indices[k]]
                ):
                found = True
                key = k
                break

        if not found:
            key = output

        output_indices[key].append(i)
        output_counts[key] += 1
        all_values.append(output.item())

    os.makedirs(results_base_path, exist_ok=True)

    results_folder = os.path.join(results_base_path, 
                                    f'{num_nodes=},{edge_prob=},{network_size=},{seed=},{num_permutations=}')
    
    os.makedirs(results_folder, exist_ok=True)

    with open(os.path.join(results_folder, 'values.json'), 'w') as f:
        json.dump(all_values, f)

    with open(os.path.join(results_folder, 'results.json'), 'w') as f:
        results = {
            'collision_probability': collision_probability(all_values)
        }
        json.dump(results, f)
    
    print(results['collision_probability'])

    return results['collision_probability']

    # # print output_counts where value is larger than 1 and sorted by value
    # print({k.item(): v for k, v in sorted(output_counts.items(),
    #                                       key=lambda item: item[1],
    #                                       reverse=True) if v > 1})

    # print("collision frequency: ", sum(
    #     [v for k, v in output_counts.items() if v > 1]) / num_permutations)

    # # check if any of the outputs have repeated:
    # if any([count > 1 for count in output_counts.values()]):
    #     print("a value was generated by multiple permutations!")
    # else:
    #     print("no value was generated in multiple permuations")


if __name__ == '__main__':
    # runnables = [(lambda: wl_experiment(num_nodes=num_nodes))
    #              for num_nodes in [64, 128, 512, 1024, 2048, 4096]]

    # #create process for each function
    # processes = [Process(target=runnable) for runnable in runnables]

    # #start all processes
    # for p in processes:
    #     p.start()

    # #wait for all processes to finish
    # for p in processes:
    #     p.join()

    # exp_func = partial(wl_experiment, 
    #         edge_prob=0.5,
    #         network_size=2,
    #         seed=42,
    #         num_permutations=200)
    

    #use poll to run runnables
    # with Pool(3) as pool:
        # results = pool.map(exp_func, [64, 128, 512, 1024, 2048, 4096])

    # for p in [0.1, 0.25, 0.75, 0.9]:
    #     wl_experiment(num_nodes=1024, 
    #                   edge_prob=p,
    #                   network_size=2,
    #                   seed=42,
    #                   num_permutations=200)

    # for network_size in [1, 3, 5, 7]:
    #     wl_experiment(num_nodes=1024, 
    #                   edge_prob=0.5,
    #                   network_size=network_size,
    #                   seed=42,
    #                   num_permutations=200)


    for num_nodes in [64, 128, 512, 1024, 2048]:
        for p in [0.1, 0.25, 0.5, 0.75, 0.9]:
            for network_size in [1, 3, 5, 7]:
                wl_experiment(num_nodes=num_nodes, 
                              edge_prob=p,
                              network_size=network_size,
                              seed=12345,
                              num_permutations=200,
                              results_base_path='results_grid_test')